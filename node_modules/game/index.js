/* --- Loading factory --- */

var ClientFactory = require("client");
var projectilePool = require("pool").Projectile;
var rocketPool = require("pool").Rocket;
var minePool = require("pool").Mine;

/* --- GameServer --- */

function GameServer() {
    this.clients = [];
}

GameServer.prototype.AddClient = function(socket) {
    var client = ClientFactory.CreateClient(socket);
    
    this.clients.push(client);
    
    return client;
};

GameServer.prototype.RemoveClient = function(id) {
    var client = this.clients.find(x => x.id == id);
    
    if (client) {
        this.clients.splice(this.clients.indexOf(client), 1);
    }
};

GameServer.prototype.Broadcast = function (type, data) {
    this.clients.forEach(function (client) {
        client.Send(type, data);
    });
};

GameServer.prototype.GetState = function () {
    var state = this.FillState();
    
    this.ProcessProjectilesCollisions(state);
    this.RemoveProjectiles();
    
    return state;
};

GameServer.prototype.RemoveProjectiles = function() {
    minePool.projectiles.filter(p => p.isActive && p.entity.markedForRemove)
        .map(p => p.entity)
        .forEach(p => minePool.ReleaseProjectile(p));
    projectilePool.projectiles.filter(p => p.isActive && p.entity.markedForRemove)
        .map(p => p.entity)
        .forEach(p => projectilePool.ReleaseProjectile(p));
    rocketPool.projectiles.filter(p => p.isActive && p.entity.markedForRemove)
        .map(p => p.entity)
        .forEach(p => {
            var client = this.clients.find(c => c.ship.id == p.emitter);
            if (client)
                client.rocketsActive--;
            rocketPool.ReleaseProjectile(p);
        });        
};

GameServer.prototype.ProcessProjectilesCollisions = function(state) {
    state.forEach(function(self) {
        if (self.type.indexOf("-projectile") > 0 || self.state == "dead")
            return;
        
        var Intersected = state.filter(function (another) {
            if (another.type == self.type)
                return false;
            
            var r1 = 15;
            var r2 = 5;
            if (another.type.indexOf("-mine") > 0)
                r2 = 10;
    
            var dx = self.x - another.x;
            var dy = self.y - another.y;
            dx = dx * dx + dy * dy;
            dy = r1 + r2;
    
            return dx < dy * dy;
        });
    
        for (var index in Intersected) {
            var Entity = Intersected[index];
            
            if (Entity.emitter != self.id)
            {
                Entity.markedForRemove = true;
                self.Damage(Entity.damage);
            }
        }
    });
    
    
};

GameServer.prototype.FillState = function() {
    var state = [];    
    
    rocketPool.UpdateActiveProjectiles(this.clients);
    projectilePool.UpdateActiveProjectiles(this.clients);
    minePool.UpdateActiveProjectiles(this.clients);
    
    for (var i = this.clients.length; i--; ) {
        state.push(this.clients[i].ship);
    }
    
    state = state.concat(rocketPool.projectiles.filter(p => p.isActive).map(p => p.entity));
    state = state.concat(projectilePool.projectiles.filter(p => p.isActive).map(p => p.entity));
    state = state.concat(minePool.projectiles.filter(p => p.isActive).map(p => p.entity));
    
    return state;
};

GameServer.prototype.StartMainLoop = function(TargetUpdatesPerSecond, loop) {
    setInterval( loop, 1000 / TargetUpdatesPerSecond);
};

/* --- Exports --- */

module.exports = new GameServer();