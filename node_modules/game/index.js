/* --- Loading factory --- */

var ClientFactory = require("client");
var projectilePool = require("pool").Projectile;
var rocketPool = require("pool").Rocket;
var minePool = require("pool").Mine;

/* --- GameServer --- */

function GameServer() {
    this.clients = [];
    this.realtimeScaleCoefficient = 1;
    this.score = [];
}

GameServer.prototype.AddClient = function(socket) {
    var self = this;
    var client = ClientFactory.CreateClient(socket, false, function(type, data) {
        self.Broadcast(type,data);
    });
    
    this.clients.push(client);
    
    return client;
};

GameServer.prototype.RemoveClient = function(id) {
    var client = this.clients.find(x => x.id == id);
    
    if (client) {
        this.clients.splice(this.clients.indexOf(client), 1);
        
        if (client.ship)
        {
            minePool.projectiles
                .filter(p => p.entity.emitter == client.ship.id)
                .forEach(x => x.entity.markedForRemove = true);
            projectilePool.projectiles
                .filter(p => p.entity.emitter == client.ship.id)
                .forEach(x => x.entity.markedForRemove = true);
            rocketPool.projectiles
                .filter(p => p.entity.emitter == client.ship.id)
                .forEach(x => x.entity.markedForRemove = true);
        }
    }
    
};

GameServer.prototype.Broadcast = function (type, data) {
    this.clients.forEach(function (client) {
        client.Send(type, data);
    });
};

GameServer.prototype.GetState = function () {
    var state = this.FillState();
    
    this.RemoveProjectiles();
    this.ProcessProjectilesCollisions(state);
    
    this.score = this.clients
      .filter(client => client.ship)
      .map(client => ({name: client.ship.name, score: client.ship.points}) )
      .sort((r1, r2) => r2.score - r1.score);
    
    return state;
};

GameServer.prototype.AddBots = function (count) {
    var self = this;
    for (; count--; ) {
        var client = ClientFactory.CreateClient(undefined, true, function(type, data) {
            self.Broadcast(type,data);
        });
        this.clients.push(client);
    }
};

GameServer.prototype.RemoveProjectiles = function() {
    minePool.projectiles.filter(p => p.isActive && p.entity.markedForRemove)
        .forEach(p => minePool.ReleaseProjectile(p.entity));
    projectilePool.projectiles.filter(p => p.isActive && p.entity.markedForRemove)
        .forEach(p => projectilePool.ReleaseProjectile(p.entity));
    rocketPool.projectiles.filter(p => p.isActive && p.entity.markedForRemove)
        .forEach(p => {
            var client = this.clients.filter(c => c.ship).find(c => c.ship.id == p.entity.emitter);
            if (client)
                client.rocketsActive--;
            rocketPool.ReleaseProjectile(p.entity);
        });        
};

GameServer.prototype.ProcessProjectilesCollisions = function(state) {
    state.forEach(self => {
        if (self.type.indexOf("-ship") < 0 || self.state == "dead")
            return;
        
        var Intersected = state.filter(function (another) {
            if (another.type.indexOf("-ship") > 0)
                return false;
            
            var r1 = self.collisionRadius;
            var r2 = another.collisionRadius;
    
            var dx = self.x - another.x;
            var dy = self.y - another.y;
            dx = dx * dx + dy * dy;
            dy = r1 + r2;
    
            return dx < dy * dy;
        });
    
        for (var index in Intersected) {
            var Entity = Intersected[index];
            
            if (Entity.emitter != self.id)
            {
                Entity.markedForRemove = true;
                self.Damage(Entity.damage, this.clients.filter(x=>x.ship && x.ship.id==Entity.emitter)[0].ship);
            }
        }
    });
    
    
};

GameServer.prototype.UpdateScaleCooefficient = function(coef) {
    if (this.realtimeScaleCoefficient != coef)
    {
        this.realtimeScaleCoefficient = coef;
        projectilePool.realtimeScaleCoefficient = coef;
        rocketPool.realtimeScaleCoefficient = coef;
        minePool.realtimeScaleCoefficient = coef;
        this.clients.forEach(client => client.realtimeScaleCoefficient = coef);
        
        console.log("Changed timescale to " + coef);
    }
}

GameServer.prototype.FillState = function() {
    var state = [];    
    var ships = this.clients.map(x => x.ship).filter(s => s);
    
    rocketPool.UpdateActiveProjectiles(ships);
    projectilePool.UpdateActiveProjectiles(ships);
    minePool.UpdateActiveProjectiles(ships);
    
    state = state.concat(rocketPool.projectiles);
    state = state.concat(projectilePool.projectiles);
    state = state.concat(minePool.projectiles);
    state = state.filter(p => p.isActive).map(p => p.entity);
    state = state.concat(ships);
    
    return state;
};

GameServer.prototype.StartMainLoop = function(TargetUpdatesPerSecond, loop) {
    setInterval(() => {
        loop();
    }, 1000 / TargetUpdatesPerSecond);
};

/* --- Exports --- */

module.exports = new GameServer();