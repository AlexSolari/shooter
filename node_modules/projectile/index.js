var VectorFactory = require("vector");

function Projectile() {
    this.id = Math.random();
    this.damage = 0;
    this.type = "";
    this.x = 0;
    this.y = 0;
    this.maxspeed = 0;
    this.speed = VectorFactory.CreateVector();
    this.markedForRemove = false;
    this.emitter = null;
    this.collisionRadius = 0;
    this.lifeSpan = 0;
    this.autotargetEnabled = false;
    this.timedLife = false;
}

Projectile.prototype.Move = function () {
    this.x += this.speed.x;
    this.y += this.speed.y;
};

Projectile.prototype.Extras = function (ships) {
    if (this.type == "common-projectile" || this.type == "plasma-projectile")
        return;
        
    var dist;
    var enemies = ships.filter(s => s && s.state != "dead" && s.id != this.emitter);
    var length = enemies.length;
    var radius = 150;
    
    switch (this.type) {
        case 'singularity-projectile':
            
            for (var i = 0; i < length; i++) {
                dist = VectorFactory.CreateVector(this.x, this.y, enemies[i].x, enemies[i].y);    
                if (dist.magnitude < radius)
                    enemies[i].Damage(this.damage/5, ships.filter(x => x && x.id == this.emitter)[0]);
                
            }
            break;
        case 'guided-small-rocket-projectile':
        case 'small-rocket-projectile':
            if (this.autotargetEnabled)
            {
                var nearest = undefined;
                var distance = Infinity;
                
                for (var i = 0; i < length; i++) {
                    dist = VectorFactory.CreateVector(this.x, this.y, enemies[i].x, enemies[i].y);
                    if (dist.magnitude < distance && dist.magnitude < radius*2)
                    {
                        nearest = enemies[i];
                        distance = dist.magnitude;
                    }
                    
                }  
                var target = nearest;
                
                if(target)
                {
                    var acceleration = VectorFactory.CreateVector(this.x, this.y, target.x, target.y,this.acceleration);
            
                    this.speed.Add(acceleration);
                
                    if (this.speed.magnitude > this.maxspeed)
                      this.speed.Limit(this.maxspeed);
                }
            }
            break;
        default:
    }
};

Projectile.prototype.CalculateDirections = function (ships) {
    if (this.emitter == null)
        return;
        
    if (this.timedLife && this.lifeSpan-- < 0){
        this.markedForRemove = true;
        return;
    }
        
    this.Extras(ships);
    this.Move();
    this.PreventGoingOutOfScreen();
};

Projectile.prototype.PreventGoingOutOfScreen = function () {
    if ((this.x < 0) || (this.y < 0) || (this.x > 1920) || (this.y > 1080))
        this.markedForRemove = true;
};

/* --- Projectile factory --- */

function ProjectileFactory() {}

ProjectileFactory.prototype.DetectStats = function (projectile) {
    switch (projectile.type) {
        case "singularity-projectile":
            projectile.maxspeed = 5;
            projectile.damage = 0.5;
            projectile.collisionRadius = -1;
            projectile.autotargetEnabled = false;
            projectile.timedLife = true;
            projectile.lifeSpan = 500;
            break;
        case "plasma-projectile":
            projectile.maxspeed = 20;
            projectile.damage = 1.5;
            projectile.collisionRadius = 2;
            projectile.lifeSpan = 50;
            projectile.timedLife = true;
            projectile.autotargetEnabled = false;
            break;
        case "small-rocket-projectile":
            projectile.maxspeed = 10;
            projectile.damage = 25;
            projectile.collisionRadius = 5;
            projectile.timedLife = true;
            projectile.lifeSpan = 200;
            projectile.acceleration = 0.5;
            projectile.autotargetEnabled = false;
            setTimeout(() => projectile.autotargetEnabled = true, 1000);
            break;
        case "guided-small-rocket-projectile":
            projectile.maxspeed = 17;
            projectile.damage = 25;
            projectile.collisionRadius = 5;
            projectile.timedLife = true;
            projectile.lifeSpan = 200;
            projectile.acceleration = 8;
            projectile.autotargetEnabled = false;
            setTimeout(() => projectile.autotargetEnabled = true, 300);
            break;
        default:
            projectile.maxspeed = 15;
            projectile.damage = 0.5;
            projectile.collisionRadius = 5;
            projectile.autotargetEnabled = false;
    }
}

ProjectileFactory.prototype.CreateProjectile = function (x,y, angle, emitter, type, spread) {
    var projectile = new Projectile();
    
    projectile.type = type || "common-projectile";    
    this.DetectStats(projectile);
    projectile.x = x;
    projectile.y = y;
    projectile.speed = VectorFactory.CreateVectorFromAngle(angle, projectile.maxspeed, spread);
    projectile.emitter = emitter;
    
    return projectile;
};

module.exports = new ProjectileFactory();