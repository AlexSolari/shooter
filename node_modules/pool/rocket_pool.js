var rocketFactory = require("rocket");
var vectorFactory = require("vector");

function RocketPool(quantity) {
    
    this.projectiles = [];
    
    for (var i = 0; i < quantity; i++) {
        var wrapper = {
            isActive: false,
            entity: rocketFactory.CreateRocket(0, 0, vectorFactory.CreateVector(), null),
        };
        this.projectiles.push(wrapper);
    }
    
}

RocketPool.prototype.ActivateProjectile = function(x, y, direction, emitter) {
    function spread() {
        return Math.random() * (1.2 - 0.8) + 0.8;
    }
    
    var wrapper = this.projectiles.find(p => !p.isActive);
    var projectile;
    
    if (!wrapper)
    {
        var newProjectile = {
            isActive: true,
            entity: rocketFactory.CreateRocket(x, y, vectorFactory.CreateVector(0, 0, direction.x * spread(), direction.y * spread()), emitter),
        };
        this.projectiles.push(newProjectile);
        return newProjectile.entity;
    }
    projectile = wrapper.entity;
    projectile.x = x;
    projectile.y = y;
    projectile.speed = vectorFactory.CreateVector(0, 0, direction.x * spread(), direction.y * spread(), projectile.maxspeed / 2);
    projectile.emitter = emitter;
    rocketFactory.DetectStats(projectile);
    
    wrapper.isActive = true;
    
    return projectile;
    
};

RocketPool.prototype.ReleaseProjectile = function(projectile) { 
    
    var wrapper = this.projectiles.find(p => p.entity.id == projectile.id);

    wrapper.entity.x = 0;
    wrapper.entity.y = 0;
    wrapper.entity.speed = null;
    wrapper.entity.emitter = null;
    wrapper.entity.markedForRemove = false;
    wrapper.entity.lifeSpan = 0;
    
    wrapper.isActive = false;
};

RocketPool.prototype.UpdateActiveProjectiles = function (clients) {
    this.projectiles.filter(p => p.isActive).forEach(p => p.entity.CalculateDirections(clients));
};

module.exports = RocketPool; 