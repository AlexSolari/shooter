var projectileFactory = require("projectile");
var vectorFactory = require("vector");

function ProjectilePool(quantity) {
    for (var i = 0; i < quantity; i++) {
        var wrapper = {
            isActive: false,
            entity: projectileFactory.CreateProjectile(0, 0, vectorFactory.CreateVector(), null),
        };
        this.projectiles.push(wrapper);
    }
    
}

ProjectilePool.prototype.projectiles = [];

ProjectilePool.prototype.ActivateProjectile = function(x, y, direction, emitter, type) {
    function spread() {
        var spreadValue;
        switch (type) {
            case 'singularity-projectile':
                spreadValue = 0;
                break;
            default:
                spreadValue = 0.4;
        }
        return Math.random() * (spreadValue - (-spreadValue)) + (-spreadValue);
    }
    
    var wrapper = this.projectiles.find(p => !p.isActive && p.entity.type == type);
    var projectile;
    
    if (!wrapper){
        var newWrapper = {
            isActive: true,
            entity: projectileFactory.CreateProjectile(x, y, vectorFactory.CreateVector(0, 0, direction.x + spread(), direction.y + spread()), emitter, type),
        }
        this.projectiles.push(newWrapper);
        return newWrapper.entity;
    }
    
    projectile = wrapper.entity;
    projectile.x = x;
    projectile.y = y;
    projectile.speed = vectorFactory.CreateVector(0, 0, direction.x + spread(), direction.y + spread(), projectile.maxspeed);
    projectile.emitter = emitter;
    projectileFactory.DetectStats(projectile);
    
    wrapper.isActive = true;
    
    return projectile;
    
}

ProjectilePool.prototype.ReleaseProjectile = function(projectile) { 

    var wrapper = this.projectiles.find(p => p.entity.id == projectile.id);
    var projectile = wrapper.entity;
    
    projectile.x = 0;
    projectile.y = 0;
    projectile.speed = null;
    projectile.emitter = null;
    projectile.markedForRemove = false;
    
    wrapper.isActive = false;
};

ProjectilePool.prototype.UpdateActiveProjectiles = function (clients) {
    this.projectiles.filter(p => p.isActive).forEach(p => p.entity.CalculateDirections(clients));
};

module.exports = ProjectilePool;